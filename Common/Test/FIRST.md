만약 Unit Test가 다음 중 하나의 경우라도 해당된다면 이는 뭔가 문제점이 있고 개선이 필요하다는 것을 의미한다.

1. 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
2. 산발적으로 실패하는 테스트
3. 어떤 가치도 증명하지 못하는 테스트
4. 실행하는 데 오래 걸리는 테스트
5. 코드를 충분히 커버하지 못하는 테스트
6. 구현과 강하게 연결되어 있어 작은 변화에도 다수의 테스트가 깨지는 테스트
7. 수많은 설정 고리로 점프하는 난해한 테스트


이를 해결하기 위해 Unit Test가 가져야 할 다섯가지 원칙을 제시하고 있으며
이는 
- Fast
- Isolated
- Repeatable
- Self-validating
- Timely
  
의 두문자를 따서 `FIRST`라고 불린다.

# Fast, 빠르게
Unit Test의 빠르고 느림은 다소 주관적인 부분이 있지만 대개 Unit Test는 내부 코드만 테스트할 시, 즉 외부 DB나 파일 입출력을 수행하지 않는 경우 수 밀리초를 소모하지만 외부 자원을 다룰 경우 시스템에 따라 더 많은 시간이 소요될 수 있다. 시스템을 설계하여 단위 테스트를 수행할 때 수천개의 Unit Test를 수행하게 된다면 이에 소모되는 시간은 기하급수적으로 늘어날 것이며 한 테스트가 평균 200ms를 소모한다면 2500개 정도의 테스트는 8분이상 시간을 소모하게 된다.

<br>

이렇게 단위 테스트에 필요한 시간이 점점 늘어나서 하루에 여러 번 수행하기가 어렵다면 이는 Unit Test Suite에 무언가 문제가 있다는 것을 의미한다.

Unit Test는 빠르게 수행되어 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백을 주는데에 그 가치가 있기 때문에 이를 달성하지 못 한다면 테스트를 작성하는 것 자체가 무의미해질 수 있다.

<br>

그렇기 때문에 최대한 느린 것에 의존하는 테스트 코드는 지양해야 할 것이다.

# Isolated, 고립된
좋은 Unit Test는 검증하려는 작은 양의 코드(Unit)에 집중해야 한다. 하나의 테스트 코드가 다른 테스트 코드와 상호작용하거나 외부 소스에 의존하는 프로덕션 코드에 대하여 테스트를 수행할 경우 테스트를 깨트리는, 통제할 수 없는 외부 상황에 의해 테스트가 실패할 수도 있으며 외부 저장소에 대한 가용성, 접근성 문제 역시 발생할 수 있다.

<br>

예를 들어 어떤 비용 높은 자원에 대하여 여러 테스트 케이스가 같이 순차적으로 돌아가면서 사용할 경우 테스트가 실패했을 때 앞선 테스트를 추적하여 원인을 찾아내느라 긴 시간을 소모하게 될 수도 있다.

<br>

그렇기 때문에 좋은 Unit Test는 다른 Unit Test나 같은 메서드에 있는 다른 테스트 케이스와도 의존하지 않는 고립된 상태여야 한다.
이는 어떤 순서나 시간에도 관계 없이 실행될 수 있어야 하며 테스트 실패 시 분명한 원인을 제공할 수 있도록 집중적인 단위로 나뉘어야 한다.

# Repeatable, 반복 가능한
완성된 하나의 Unit Test는 결과가 어떻게 나올지 명확해야 하며 모든 결과는 통제 아래 있어야 한다. 반복적으로 사용할 수 있는 테스트는 실행할 때마다 결과가 같아야 한다. 
이를 위해서 가장 좋은 방법은 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시키는 것이나 항상 격리시킬 수는 없고 시스템은 불가피하게 외부 요소와 상호작용하게 될 것이다.

<br>

대표적으로 `시간`을 테스트하는 경우를 예로 들어보자. 어떤 값이 자료구조에 추가되었을 때 이에 대한 Timestamp를 남기는 기능을 테스트하려고 한다면 시간은 항상 흐르고 있으므로 추가되었을 때 남겨진 Timestamp와 실제로 테스트할 때 비교하는 Timestamp의 간격이 발생할 수 있으므로 이를 단언하기한 쉽지 않을 것이다. 어떨 때는 오차범위 이내로 비교되어 통과하거나, 그렇지 않을 수도 있다. 이는 산발적인 테스트 성공/실패로 해당 테스트 실패가 거짓인지 진실인지 알 수 없어 1종/2종 오류를 범하게 될 수 있으므로 좋은 Unit Test라 할 수 없다.

<br>

그렇기 때문에 이때는 테스트 대상 코드의 나머지를 격리하고 독립성을 유지하기 위해 Mock Object를 활용하는 방안 등을 사용하여야 한다. 시간 관련 라이브러리를 사용하여 가짜 시간 객체를 넘겨서 출처에 상관없이 비교하는 것이다. 이외의 경우(DB 등)에는 아예 다른 개발자들과의 충돌을 피하기 위해 따로 샌드박스 환경을 만들어 테스트하거나 별도의 서버를 따로 구축할 수도 있을 것이다.

# Self-validating, 스스로 검증 가능한
테스트 결과를 수동으로 비교하는 것은 시간을 소모하고 지치는 일이며 수많은 로그의 바다를 헤엄치다 정작 중요한 신호를 놓칠 수도 있다. 그렇기 때문에 테스트는 해당 작업(Act)의 결과값이 옳은지 스스로 검증 가능하며 이를 준비하는 작업 역시 스스로 수행할 수 있어야 한다.
발전된 테스트 체계의 경우 자가 검증성을 극대화하여 시스템에 변화가 생긴다면 자동으로 테스트를 수행하도록 하는 경우도 있다.

좀 더 큰 규모에서는 Jenkins가 TeamCity같은 CI(Continuous Intergration) 도구를 사용할 수 있다. 이는 소스 저장소를 관찰하여 변화를 감지하면 빌드와 테스트 절차를 자동적으로 수행한다.
여기서 빌드 서버가 이를 판단하여 프로덕션 시스템에 변경 사항을 반영한다면 CD(Continuos Delivery)를 수행하는 것이며 이는 제품 배포에 소모되는 오버헤드를 크게 줄일 수 있다.

<br>

# Timely, 적시에
사실 프로덕션 시스템에 따라 Unit Test는 별로 필요없을 수도 있다. 강요되는 사하잉 아닌 만큼 언제라도 그만둘 수 있고 언제라도 적용할 수 있다. 어쩔땐 레거시 코드에 Unit Test를 적용할 수도 있겠지만 가능하면 적절한 순간에 Unit Test에 집중하는 편이 권장된다. 옛날 코드에 큰 결함이 없고 당장 변경사항을 적용해야 하는 경우가 아니라면 레거시에 대한 Unit Test보다는 역동적이고 잔고장이 많은 부분에 수행하는 것이 바람직하다.

<br> 

Unit Test는 수행하면 수행할수록 어느 부분에 테스트가 필요한지 명확해지기 때문에 테스트 대상 코드가 줄어들며 이런 경험이 반복될수록 테스트를 작성하기 쉬워진다. 또한 새로운 코드를 작성한 후에 테스트를 수행하면 그 효과를 즉시 볼 수 있다. 이런 장점들로 인해 소프트웨어 개발 프로세스에 `테스트 주도 개발(TDD, Test-Driven Development)`같은 프로세스가 등장하였다고 할 수 있다.

<br>

Unit Test는 소프트웨어 개발의 완성도, 품질을 높이는 좋은 습관이며 이를 이용하여 코드를 검증하는 습관을 가지지 않는다면 코드에 결함이 발생할 확률이 높아진다. 그렇기 때문에 많은 개발팀에서는 팀의 단위 테스트에 대하여 엄격하게 수행하고 있다.


<br>

## 요약
  
### Fast
- 테스트 코드를 빠르게 유지하라
- 시스템이 커지면 Unit Test도 실행하는 데 점점 오래 걸린다
- Unit Test의 가치는 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백에 있다
- 설계를 깨끗하게 하고, 외부 자원 호출을 줄이고, 느린 테스트에 대한 의존성을 줄여야 한다.
  
### Isolated
- 직∙간접적으로 상호작용하는 코드를 최소화하라
- 외부 데이터 의존성은 테스트가 가용성 혹은 접근성을 이유로 실패할 가능성을 증가시킨다
- 다른 Unit Test에 의존하지 않고, 어떤 순서나 시간에 관계없이 실행할 수 있어야 한다

### Repeatable
- 반복 가능한 테스트는 그걸 실행할 때마다 결과가 같아야한다
- 모든 테스틑 전적으로 프로그래머의 통제 하에 있어야 한다
- 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시켜야 한다

    ex) 현재 시간을 나타내는 Mock Object 사용

### Self-validating
- 테스트의 결과를 기대하는 것이 무엇인지 단언할 수 있어야 하고 검증할 수 있어야 한다
- 테스트에 필요한 어떤 설정 단게든 자동화를 해야한다

### Timely
- Unit Test로 적시에 코드를 검증해야 한다
- 역동적이고 새로운 코드들에 대해 우선적으로 Unit Test를 수행하는 것이 효과적이다